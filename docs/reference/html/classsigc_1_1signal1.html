<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libsigc++: sigc::signal1&lt; T_return, T_arg1, T_accumulator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++&#160;<span id="projectnumber">2.2.10</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesigc.html">sigc</a> </li>
      <li class="navelem"><a class="el" href="classsigc_1_1signal1.html">signal1</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> </div>
  <div class="headertitle">
<h1>sigc::signal1&lt; T_return, T_arg1, T_accumulator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__signal.html">Signals</a></div></h1> </div>
</div>
<div class="contents">
<!-- doxytag: class="sigc::signal1" --><!-- doxytag: inherits="sigc::signal_base" -->
<p>Signal declaration. <a href="#_details">More...</a></p>

<p><code>#include &lt;sigc++/signal.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sigc::signal1&lt; T_return, T_arg1, T_accumulator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classsigc_1_1signal1__inherit__graph.png" border="0" usemap="#sigc_1_1signal1_3_01T__return_00_01T__arg1_00_01T__accumulator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="sigc_1_1signal1_3_01T__return_00_01T__arg1_00_01T__accumulator_01_4_inherit__map" id="sigc_1_1signal1_3_01T__return_00_01T__arg1_00_01T__accumulator_01_4_inherit__map">
<area shape="rect" id="node7" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4_1_1accumulated.html" title="Convenience wrapper for the numbered sigc::signal1 template." alt="" coords="5,237,453,267"/><area shape="rect" id="node2" href="structsigc_1_1signal__base.html" title="Base class for the sigc::signal# templates." alt="" coords="164,83,295,112"/><area shape="rect" id="node4" href="structsigc_1_1trackable.html" title="Base class for objects with auto&#45;disconnection." alt="" coords="172,5,287,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classsigc_1_1signal1-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63c6e2b55c8c3af083402bb7f5a66593"></a><!-- doxytag: member="sigc::signal1::emitter_type" ref="a63c6e2b55c8c3af083402bb7f5a66593" args="" -->
typedef internal::signal_emit1<br class="typebreak"/>
&lt; T_return, T_arg1, <br class="typebreak"/>
T_accumulator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>emitter_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcdcfa50d60e1832ce038a4a5554fce1"></a><!-- doxytag: member="sigc::signal1::result_type" ref="adcdcfa50d60e1832ce038a4a5554fce1" args="" -->
typedef emitter_type::result_type&#160;</td><td class="memItemRight" valign="bottom"><b>result_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30b59d44cc9ab48cb39f040cbfc3a526"></a><!-- doxytag: member="sigc::signal1::slot_type" ref="a30b59d44cc9ab48cb39f040cbfc3a526" args="" -->
typedef <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slot_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fadeb350140d6aaf560b217e7e7c4b4"></a><!-- doxytag: member="sigc::signal1::slot_list_type" ref="a5fadeb350140d6aaf560b217e7e7c4b4" args="" -->
typedef <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>slot_list_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61e2d1fcaf903dffbb26b01800907fb"></a><!-- doxytag: member="sigc::signal1::iterator" ref="ab61e2d1fcaf903dffbb26b01800907fb" args="" -->
typedef <a class="el" href="structsigc_1_1slot__iterator.html">slot_list_type::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e262b35c9574e65b2607cdfcaad707"></a><!-- doxytag: member="sigc::signal1::const_iterator" ref="af1e262b35c9574e65b2607cdfcaad707" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structsigc_1_1slot__const__iterator.html">slot_list_type::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0443049aa736d88770d0f534600b2bc"></a><!-- doxytag: member="sigc::signal1::reverse_iterator" ref="ab0443049aa736d88770d0f534600b2bc" args="" -->
typedef <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00855.html">slot_list_type::reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb327519f808dfec9a723511ef82caa3"></a><!-- doxytag: member="sigc::signal1::const_reverse_iterator" ref="aeb327519f808dfec9a723511ef82caa3" args="" -->
typedef <br class="typebreak"/>
<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00855.html">slot_list_type::const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1slot__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#aac2ade0896bd4a982777d5dd6ac75888">connect</a> (const <a class="el" href="classsigc_1_1slot.html">slot_type</a>&amp; slot_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a slot to the list of slots. <a href="#aac2ade0896bd4a982777d5dd6ac75888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83">emit</a> (typename type_trait&lt; T_arg1 &gt;::take _A_a1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the emission of the signal. <a href="#a3d6fc96f07c19d77e5eab9925c101c83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#ac877a1227874a77258d28376ecb99810">emit_reverse</a> (typename type_trait&lt; T_arg1 &gt;::take _A_a1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the emission of the signal in reverse order (see <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>). <a href="#ac877a1227874a77258d28376ecb99810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#a5f150c88559aacf13edd07bd7917c96a">operator()</a> (typename type_trait&lt; T_arg1 &gt;::take _A_a1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>). <a href="#a5f150c88559aacf13edd07bd7917c96a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; result_type, <a class="el" href="classsigc_1_1signal1.html">signal1</a>, <br class="typebreak"/>
typename type_trait&lt; T_arg1 &gt;<br class="typebreak"/>
::take &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#a3b476d67c4622e69aeb4d495603d9fad">make_slot</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor that calls <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a> on this signal. <a href="#a3b476d67c4622e69aeb4d495603d9fad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#a7653b68e6a3b8445de91f89060bf2600">slots</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots. <a href="#a7653b68e6a3b8445de91f89060bf2600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html#af43eb365c7c52560f1c4c1eb3340155d">slots</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots. <a href="#af43eb365c7c52560f1c4c1eb3340155d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3378dd754ffddb4760f2a3afb271dbe"></a><!-- doxytag: member="sigc::signal1::signal1" ref="ab3378dd754ffddb4760f2a3afb271dbe" args="(const signal1 &amp;src)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>signal1</b> (const <a class="el" href="classsigc_1_1signal1.html">signal1</a>&amp; src)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T_return, class T_arg1, class T_accumulator = nil&gt;<br/>
 class sigc::signal1&lt; T_return, T_arg1, T_accumulator &gt;</h3>

<p>Signal declaration. </p>
<p><a class="el" href="classsigc_1_1signal1.html" title="Signal declaration.">signal1</a> can be used to <a class="el" href="classsigc_1_1signal1.html#aac2ade0896bd4a982777d5dd6ac75888" title="Add a slot to the list of slots.">connect()</a> slots that are invoked during subsequent calls to <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>. Any functor or slot can be passed into <a class="el" href="classsigc_1_1signal1.html#aac2ade0896bd4a982777d5dd6ac75888" title="Add a slot to the list of slots.">connect()</a>. It is converted into a slot implicitly.</p>
<p>If you want to connect one signal to another, use <a class="el" href="classsigc_1_1signal1.html#a3b476d67c4622e69aeb4d495603d9fad" title="Creates a functor that calls emit() on this signal.">make_slot()</a> to retrieve a functor that emits the signal when invoked.</p>
<p>Be careful if you directly pass one signal into the <a class="el" href="classsigc_1_1signal1.html#aac2ade0896bd4a982777d5dd6ac75888" title="Add a slot to the list of slots.">connect()</a> method of another: a shallow copy of the signal is made and the signal's slots are not disconnected until both the signal and its clone are destroyed, which is probably not what you want!</p>
<p>An STL-style list interface for the signal's list of slots can be retrieved with <a class="el" href="classsigc_1_1signal1.html#a7653b68e6a3b8445de91f89060bf2600" title="Creates an STL-style interface for the signal&#39;s list of slots.">slots()</a>. This interface supports iteration, insertion and removal of slots.</p>
<p>The following template arguments are used:</p>
<ul>
<li><em>T_return</em> The desired return type for the <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a> function (may be overridden by the accumulator).</li>
<li><em>T_arg1</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>.</li>
<li><em>T_accumulator</em> The accumulator type used for emission. The default <code>nil</code> means that no accumulator should be used, for example if signal emission returns the return value of the last slot invoked.</li>
</ul>
<p>You should use the more convenient unnumbered <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a> template. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aac2ade0896bd4a982777d5dd6ac75888"></a><!-- doxytag: member="sigc::signal1::connect" ref="aac2ade0896bd4a982777d5dd6ac75888" args="(const slot_type &amp;slot_)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1slot__iterator.html">iterator</a> <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsigc_1_1slot.html">slot_type</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a slot to the list of slots. </p>
<p>Any functor or slot may be passed into <a class="el" href="classsigc_1_1signal1.html#aac2ade0896bd4a982777d5dd6ac75888" title="Add a slot to the list of slots.">connect()</a>. It will be converted into a slot implicitely. The returned iterator may be stored for disconnection of the slot at some later point. It stays valid until the slot is removed from the list of slots. The iterator can also be implicitely converted into a <a class="el" href="structsigc_1_1connection.html" title="Convinience class for safe disconnection.">sigc::connection</a> object that may be used safely beyond the life time of the slot. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_</td><td>The slot to add to the list of slots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the new slot in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d6fc96f07c19d77e5eab9925c101c83"></a><!-- doxytag: member="sigc::signal1::emit" ref="a3d6fc96f07c19d77e5eab9925c101c83" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">result_type <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::emit </td>
          <td>(</td>
          <td class="paramtype">typename type_trait&lt; T_arg1 &gt;::take&#160;</td>
          <td class="paramname"><em>_A_a1</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Triggers the emission of the signal. </p>
<p>During signal emission all slots that have been connected to the signal are invoked unless they are manually set into a blocking state. The parameters are passed on to the slots. If <em>T_accumulated</em> is not <code>nil</code>, an accumulator of this type is used to process the return values of the slot invocations. Otherwise, the return value of the last slot invoked is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_a1</td><td>Argument to be passed on to the slots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The accumulated return values of the slot invocations. </dd></dl>

</div>
</div>
<a class="anchor" id="ac877a1227874a77258d28376ecb99810"></a><!-- doxytag: member="sigc::signal1::emit_reverse" ref="ac877a1227874a77258d28376ecb99810" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">result_type <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::emit_reverse </td>
          <td>(</td>
          <td class="paramtype">typename type_trait&lt; T_arg1 &gt;::take&#160;</td>
          <td class="paramname"><em>_A_a1</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Triggers the emission of the signal in reverse order (see <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>). </p>

</div>
</div>
<a class="anchor" id="a3b476d67c4622e69aeb4d495603d9fad"></a><!-- doxytag: member="sigc::signal1::make_slot" ref="a3b476d67c4622e69aeb4d495603d9fad" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;result_type, <a class="el" href="classsigc_1_1signal1.html">signal1</a>, typename type_trait&lt;T_arg1&gt;::take&gt; <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::make_slot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor that calls <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a> on this signal. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun</a>(mysignal, &amp;<a class="code" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">sigc::signal1::emit</a>)
</pre></div><p> yields the same result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A functor that calls <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a> on this signal. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f150c88559aacf13edd07bd7917c96a"></a><!-- doxytag: member="sigc::signal1::operator()" ref="a5f150c88559aacf13edd07bd7917c96a" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">result_type <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">typename type_trait&lt; T_arg1 &gt;::take&#160;</td>
          <td class="paramname"><em>_A_a1</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal1.html#a3d6fc96f07c19d77e5eab9925c101c83" title="Triggers the emission of the signal.">emit()</a>). </p>

</div>
</div>
<a class="anchor" id="a7653b68e6a3b8445de91f89060bf2600"></a><!-- doxytag: member="sigc::signal1::slots" ref="a7653b68e6a3b8445de91f89060bf2600" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a> <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::slots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an STL-style interface for the signal's list of slots. </p>
<p>This interface supports iteration, insertion and removal of slots. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>

</div>
</div>
<a class="anchor" id="af43eb365c7c52560f1c4c1eb3340155d"></a><!-- doxytag: member="sigc::signal1::slots" ref="af43eb365c7c52560f1c4c1eb3340155d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a> <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a>&lt; T_return, T_arg1, T_accumulator &gt;::slots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an STL-style interface for the signal's list of slots. </p>
<p>This interface supports iteration, insertion and removal of slots. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Jul 25 2011 09:51:23 for libsigc++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
